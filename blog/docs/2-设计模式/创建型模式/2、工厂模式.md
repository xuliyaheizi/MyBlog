---
title: 工厂模式
date: 2022-10-16
description: 编写软件过程中，面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性和灵活性等多方面的挑战。
tags:
 - 设计模式
categories:
 - Java
publish: true

---

## 工厂模式

### 2.2、简单工厂模式

`简单工厂模式(Simple Fatory Pattern)`，又称静态工厂方法模式，属于`类创建型模式`。是可以**根据参数的不同来返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

```java
/**
 * 传统方法，违反了ocp原则，对扩展开发，对修改关闭、
 * 这里添加一个新的种类，会修改大量代码
 */
public OrderPizza() {
    Pizza pizza = null;
    //订购披萨的类型
    String orderType;
    do {
        orderType = getType();
        if ("greek".equals(orderType)) {
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        } else if ("cheese".equals(orderType)) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        } else if ("pepper".equals(orderType)) {
            pizza = new PepperPizza();
            pizza.setName("薄荷披萨");
        } else {
            break;
        }
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
    } while (true);
}
```

**优缺点：**

- 优点：比较好理解，简单易操作
- 缺点：违反了设计模式的ocp原则，即对外扩展，对修改关闭。当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码

**简单工厂模式：**

1. 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用**的模式

- 简单工厂模式：定义一个创建对象的类，由**这个类来封装实例化对象的行为**

**缺点：**

- 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背聚合原则。
- 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统类的复杂度和理解难度。
- 系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。
- 简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构。

<img src="https://oss.zhulinz.top/newImage/202210161922360.png"/>

```java
Pizza pizza = null;
String orderType = "";

public OrderPizza2() {

    do {
        orderType = getType();
        pizza = SimpleFactory.createPizza(orderType);

        if (pizza != null) {
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        } else {
            System.out.println("pizza==null");
            break;
        }
    } while (true);
}

static String getType() {
    try {
        BufferedReader strain = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("input pizza 种类:");
        String str = strain.readLine();
        return str;
    } catch (IOException e) {
        e.printStackTrace();
        return "";
    }
}
```

```java
public class SimpleFactory {

    /**
     * 创建披萨
     * @param orderType
     * @return
     */
    public static Pizza createPizza(String orderType) {
        Pizza pizza = null;

        System.out.println("使用简单工厂模式");
        if ("greek".equals(orderType)) {
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        } else if ("cheese".equals(orderType)) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        } else if ("pepper".equals(orderType)) {
            pizza = new PepperPizza();
            pizza.setName("薄荷披萨");
        }
        return pizza;
    }

}
```

#### 2.2.2、工厂模式

- 工厂模式中，要增加产品类时也要相应地增加工厂类，客户端的代码也增加了不少。工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。
- 你想要加功能，本来是改工厂类的，而现在是修改客户端。而且各个不同功能的实例对象的创建代码，也没有耦合在同一个工厂类里，这也是工厂方法模式对简单工厂模式解耦的一个体现。工厂方法模式**克服了简单工厂会违背开-闭原则的缺点**，又保持了封装对象创建过程的优点。
- 但工厂方法模式的缺点是每增加一个产品类，就需要增加一个对应的工厂类，增加了额外的开发量。
- 但缺点在于，每增加一个产品都需要增加一个具体产品类和实现工厂类，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。

工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

<img src="https://oss.zhulinz.top/newImage/202210161922425.png"/>

#### 2.2.3、抽象工厂模式

- 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
- 抽象工厂模式可以将**简单工厂模式和工厂方法模式进行整合**。
- 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
- 将工厂抽象成两层，AbsFactory(抽象工厂)和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

<img src="https://oss.zhulinz.top/newImage/202210161922382.png"/>

#### 2.2.4、工厂模式小结

- 工厂模式的意义
  - 将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
- 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式)
- 设计模式的依赖抽象原则
  - 创建对象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
  - 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
  - 不要覆盖基类中已经实现的方法。
- 工厂方法模式与抽象工厂模式的区别在于：
  - 工厂方法只有**一个抽象产品类和一个抽象工厂类**，但可以派生出多个具体产品类和具体工厂类，每个具体工厂类只能创建一个具体产品类的实例。
  - 抽象工厂模式拥有**多个抽象产品类（产品族）和一个抽象工厂类**，每个抽象产品类可以派生出多个具体产品类；抽象工厂类也可以派生出多个具体工厂类，同时每个具体工厂类可以创建多个具体产品类的实例
---
title: 设计原则
date: 2022-07-16
description: 编写软件过程中，面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性和灵活性等多方面的挑战。
tags:
 - Java
 - 设计模式
categories:
 -  Java
publish: true

---

良好的设计原则和设计模式，才能让我们写出更加优秀的代码或者设计更好的软件架构。在编写软件过程中，往往面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性和灵活性等多方面的挑战。

- `代码重用性：`即相同功能的代码，不用多次编写，降低冗余。
- `可读性：`即编程规范性，便于其他程序员的阅读和理解。
- `可扩展性：`即当需要增加新的功能时，非常的方便，也称为可维护性。
- `可靠性：`即当我们增加新的功能后，对原来的功能没有影响。
- `使程序呈现高内聚、低耦合的特性：`即模块内部紧密，当模块间依赖小，一者出错不影响其他者。

<!-- more -->

## 七大原则

### 1.1、单一职责

**单一职责原则(Single Responsibility Principle, SRP)**：对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1、职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。

```java
public class SingleResponsibility {

    public static void main(String[] args) {
        System.out.println("方案一========================");
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("公交车");
        vehicle.run("飞机");

        System.out.println("方案二========================");
        RoadVehicle roadVehicle = new RoadVehicle();
        roadVehicle.run("汽车");
        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run("飞机");
        WaterVehicle waterVehicle = new WaterVehicle();
        waterVehicle.run("轮船");

        System.out.println("方案三========================");
        Vehicle2 vehicle2 = new Vehicle2();
        vehicle2.roadRun("汽车");
        vehicle2.airRun("飞机");
        vehicle2.waterRun("轮船");
    }
}

/**
 * 交通工具类
 * 方案一：
 * 在run()方法中，违法了单一职责原则
 * 解决方案：根据交通工具运行方法不同，分解成不同的类即可
 */
class Vehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "在公路上跑........");
    }
}

/**
 * 方案二：
 * 1. 遵守单一职责原则
 * 2. 但是这样做的改动很大，即将类分解，同时修改客户端
 * 3. 改进：直接修改 Vehicle 类，改动的代码会比较少=>方案 3
 */
class RoadVehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "在公路上跑...");
    }
}

class AirVehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "在天空里跑...");
    }
}

class WaterVehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "在海里跑...");
    }
}

/**
 * 方式 3 的分析
 * 1. 这种修改方法没有对原来的类做大的修改，只是增加方法
 * 2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
 */
class Vehicle2 {
    public void roadRun(String vehicle) {
        System.out.println(vehicle + "在公路上跑...");
    }

    public void airRun(String vehicle) {
        System.out.println(vehicle + "在天空上跑...");
    }

    public void waterRun(String vehicle) {
        System.out.println(vehicle + "在海里上跑...");
    }
}
```
> **单一职责原则注意事项和细节**

1. 降低类的复杂度，一个类只负责一项职责。
1. 提高类的可读性，可维护性
1. 降低变更引起的风险
1. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

> **单一职责的核心**

通过`高内聚、低耦合`的设计方案，将一个庞大的系统拆成单一职责的小功能，再通过`灵活组合`的方式完成功能，好处是可以通过不断的组合，应对不断变化的场景。

### 1.2、接口隔离

客户端不应该依赖它不需要的接口，即**一个类对另一个类的依赖应该建立在最小的接口上**。
<img src="https://oss.zhulinz.top//img/1651666635657-1d054332-9264-4ae1-82a1-7f964694ab2c.png" alt="img"/>

1. 类A通过`接口Interface1`依赖类B，类C通过`接口Interface1`依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。
1. **按隔离原则应当这样处理：**
将接口Interface1拆分为独立的几个接口(这里我们拆分成3个接口)，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

> **传统方法的问题和使用接口隔离原则改进**

1. 类A通过`接口Interface1`依赖类B，类C通过`接口Interface1`依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。
1. 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
1. 接口Interface1中出现的方法，根据实际情况拆分为三个接口。

<img src="https://oss.zhulinz.top//img/1651666967125-98260b17-2b45-465a-ab42-6592298397e2.png" alt="img"/>

### 1.3、依赖倒转

**依赖倒转原则(Dependence Inversion Principle)**是指：

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
1. 抽象不应该依赖细节，细节应该依赖抽象
1. 依赖倒转(倒置)的中心思想是面向接口编程
1. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
1. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

> **依赖关系传递的三种方式和应用案例**

- 接口传递
- 构造器传递
- setter方法传递

### 1.4、里氏替换

> **OO中的继承性的思考和说明**

1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果**子类对这些已经实现的方法任意修改**，就会对整个继承体系造成破坏。
1. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用**继承会给程序带来侵入性**，程序的可移植性降低，**增加对象间的耦合性**，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。
1. 问题提出：在编程中，如何正确的使用继承? =>里氏替换原则

> **里氏替换原则的定义**

- 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
- 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法。
   - 为什么这么说呢：

          继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障(重点所在)
   
- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖**来解决问题。

### 1.5、开闭原则

> **开闭原则**就是`对扩展开发`，`对修改关闭`。在程序需要进行扩展的时候，不能去修改原先的代码，实现一个热插拔的效果。为了程序的扩展性好，易于维护和升级，就需要使用接口和抽象类来达到这样的效果。

- 开闭原则(Open Closed Principle)一个软件实体如类，**模块和函数应该对扩展开放(对提供方)**，对**修改关闭**(对使用方)。
- 也就是当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。用抽象构建框架，用实现扩展细节。
- 开闭原则是编程中最基础、最重要的设计原则。编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

在实际开发过程中，常会遇到一个功能改需求或增加需求的情况，一般的做法会去修改这个功能的源代码，但这种做法严重违反了开闭原则。并且这个代码可能不止你在使用，很容易造成`牵一发而动全身`的效果。一般的准则是：

1. 如果一个类是自己写的，自己修改不会影响该类在其他地方的效果，那么可以随意修改。
2. 如果不是自己写，自己不清楚修改后会带来什么样的影响，就不要修改，要符合`开闭原则`。

### 1.6、迪米特法则

迪米特法则(Demeter Principle)又叫**最少知道原则**，即`一个类对自己依赖的类知道的越少越好，核心是降低类之间的耦合`。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。

避免与非直接朋友的耦合，只与直接的朋友通信，所谓的**直接朋友是出现成员变量，方法参数，方法返回值中的类**。而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。比如有学院员工类和学校员工类，然后各有一个管理类有可以获取其所有员工，学校员工管理类有方法打印全部员工。

<img src="https://oss.zhulinz.top//img/1651679221288-661cd15b-5d87-46f2-b71b-dbf527daf5d4.png"/>

分析SchoolManager类，发现Employee和CollegeManager都是它的直接朋友（出现在参数和返回值中)，但CollegeEmployee不是直接朋友，是以局部变量的形式，违背了迪米特原则。改进：避免依赖CollegeEmployee，封装在CollegeManager中，对外提供public方法即可。

<img src="https://oss.zhulinz.top//img/1651679249705-77c1ec97-b6be-42dd-a640-61b26152ca02.png"/>

> **注意事项和细节**

- 迪米特法则的核心是降低类之间的耦合
- 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系

### 1.7、合成复用原则

合成复用原则(Composite Reuse Principle)就是是尽量使用**组合或聚合**的方式，而不是使用**继承**。

<img src="https://oss.zhulinz.top//img/1651748485102-afebe46a-b205-47d1-8213-83dd2a45f03a.png" style="width:40%"/>

> 1. **创建型模式：**单例模式，抽象工厂模式，原型模式，建造者模式，工厂模式
> 1. **结构型模式：**适配器模式，桥接模式，装饰模式，组合模式，外观模式，亨元模式，代理模式
> 1. **行为型模式：**模板方法模式，命令模式，访问者模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式(责任链模式)



